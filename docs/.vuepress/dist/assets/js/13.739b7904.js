(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{368:function(n,t,a){"use strict";a.r(t);var e=a(45),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[n._v("#")]),n._v(" 面向对象")]),n._v(" "),a("h2",{attrs:{id:"类的祖宗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的祖宗"}},[n._v("#")]),n._v(" 类的祖宗")]),n._v(" "),a("p",[n._v("类的祖宗object\n所有的类都默认继承Object\n常用方法：")]),n._v(" "),a("ul",[a("li",[n._v("clone（）")]),n._v(" "),a("li",[n._v("finalize（）")]),n._v(" "),a("li",[n._v("equals（）")]),n._v(" "),a("li",[n._v("toString()")])]),n._v(" "),a("h3",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[n._v("#")]),n._v(" 例子")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('public class Day02 {\n    //重写tostring方法\n    @Override\n    public String toString() {\n        return "在"+getClass().getName()+"类中重写tostring（）";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new Day02());\n    }\n}\n')])])]),a("h2",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[n._v("#")]),n._v(" 继承")]),n._v(" "),a("ul",[a("li",[n._v("继承的关键字extends")]),n._v(" "),a("li",[n._v("子类继承父类的非私有的成员变量、方法")]),n._v(" "),a("li",[n._v("通过关键字super来调用父类的构造方法")]),n._v(" "),a("li",[n._v("子类继承父类之后可以重写父类的方法")])]),n._v(" "),a("h3",{attrs:{id:"例子-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子-2"}},[n._v("#")]),n._v(" 例子")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//父类\npublic class Day01 {\n    //构造方法\n    public Day01(){\n        System.out.println("父类构造方法");\n    }\n    //成员方法\n    protected void doSomething(){\n        System.out.println("这是一个成员方法");\n    }\n    //返回类型的方法\n    protected  Day01 dolt(){\n        return new Day01();  //返回一个新对象会调用构造方法\n    }\n\n}\n//子类，继承了父类\nclass Day01_sun extends  Day01{\n    public Day01_sun(){\n        //调用父类的构造方法\n        super();\n        super.doSomething();\n    }\n    //新建子类的方法\n    public void doSomethingNew(){\n        System.out.println("这是一个子类的方法");\n    }\n    //重写父类的方法\n    @Override\n    protected void doSomething() {\n        super.doSomething();\n    }\n    //重写父类的方法，返回值为Day01_sun\n    protected  Day01_sun dolt(){\n        return new Day01_sun();\n    }\n//主方法\npublic static void main(String[] args) {\n    Day01_sun day01_sun = new Day01_sun(); //创建对象之后调用父类的构造方法\n    day01_sun.doSomethingNew(); //执行子类自有方法\n    day01_sun.doSomething(); //调用重写父类的doSomething\n    day01_sun.dolt(); //调用子类构造方法\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"方法的重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法的重载"}},[n._v("#")]),n._v(" 方法的重载")]),n._v(" "),a("p",[n._v("方法的重载：为了实现方法名相同形参不同的构造方法同时存在")]),n._v(" "),a("p",[n._v("使用场景，可能同一方法会通过不同的参数来实现不同的业务")]),n._v(" "),a("h3",{attrs:{id:"例子-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子-3"}},[n._v("#")]),n._v(" 例子")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('public class Day03 {\n        //定义一个方法\n    public static  int add(int a,int b){\n        return  a+b;\n    }\n        //不同参数方法\n    public static double add(double a, double b){\n        return  a+b;\n    }\n\n    public static  int add(int a){\n        return  a;\n    }\n    public static int add(int a,double b){\n        return 1;\n    }\n\n    public  static  int  add(double a,int b){\n        return 1;\n    }\n    //不定长参数方法\n    public  static  int add(int ... a){\n        int s =0;\n        for (int i=0; i<a.length;i++){\n            System.out.println("执行第"+i+"次的值为："+a[i]);\n            s +=a[i];\n\n        }\n        return s;\n    }\n    public static void main(String[] args) {\n        System.out.println("调用add(int,int)方法:"+add(1,2));\n        System.out.println("调用add(double,double)方法:"+add(2.5,3.5));\n        System.out.println("调用add（int）方法:"+add(2));\n        System.out.println("调用不定长参数:"+add(1,2,3,4,5,6,7,8,9));\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[n._v("#")]),n._v(" 多态")]),n._v(" "),a("p",[n._v("多态的目的是程序具有良好的扩展性")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('public class Day04 {\n    //实例话保存四边形数组对象\n    private Day04[] quet = new Day04[6];\n    private int nextIndex=0;\n    public void draw(Day04 q){\n        while (true){\n        if (nextIndex < quet.length){\n            quet[nextIndex] = q;\n            System.out.println("存储到下标:"+nextIndex+"中");\n            nextIndex++;\n        }else {\n            nextIndex=0;\n            break;\n        }\n        }\n    }\n\n    public static void main(String[] args) {\n        Day04 q = new Day04();\n         //以正方形对象为参数调用draw（） ，这里会先调用 Square()构造方法，之后执行draw（）方法\n        q.draw(new Square());\n        q.draw(new ParalleLogarmgle());//调用方式与上方同理\n    }\n    \n}\nclass Square extends  Day04{\n    public  Square(){\n        System.out.println("画一个正方形");\n    }\n}\n\nclass ParalleLogarmgle extends  Day04{\n    public ParalleLogarmgle(){\n        System.out.println("画一个菱形");\n    }\n}\n')])])]),a("h2",{attrs:{id:"抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[n._v("#")]),n._v(" 抽象类")]),n._v(" "),a("p",[n._v("抽象类的关键字abstract，实际过程中我们一般将父类定义为抽象了，用来继承和多态处理\n抽象类中只有抽象方法，抽象方法除非被重写，否者没有任何意义")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('public abstract class Day05 {\n    abstract  void test(Day05 t);\n}\n\n\nclass  test1 extends  Day05 {\n    public  test1(){\n        System.out.println("这里会输出tst1构造方法");\n    }\n    //重写父类的抽象方法实现子类的多态\n    @Override\n    void test(Day05 t) {\n        System.out.println("这里会输出tst1");\n    }\n}\n\nclass test2 extends  Day05{\n    //构造方法\n    public  test2(){\n        System.out.println("这里会输出tst2构造方法");\n    }\n    //重写父类的抽象方法实现子类的多态\n    @Override\n    void test(Day05 t) {\n        System.out.println("这里会输出tst2");\n    }\n}\n\nclass  test3 {\n    public static void main(String[] args) {\n        test1 test1 =new test1();\n        test1.test(new test1());\n\n        test2 test2 = new test2();\n        test2.test(new test1());\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[n._v("#")]),n._v(" 接口")]),n._v(" "),a("p",[n._v("接口的关键字 interface ，接口可以看成是抽象类的衍生，接口中只有方法，没有方法体")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//定义一个接口\ninterface  drawTest{\n        public void draw(); //接口中方法\n\n}\n//父类\npublic class Day06 {\n\n    public  void doAnything(){\n        System.out.println("我是父级的doAnything方法");\n    }\n\n}\n//子类\nclass  Day06_sum extends Day06 implements drawTest{\n    //重写接口\n    @Override\n    public void draw() {\n        System.out.println("重写了接口中的方法");\n    }\n    //继承于父类，重写父类的方法\n    @Override\n    public void doAnything() {\n        super.doAnything();\n    }\n\n    public static void main(String[] args) {\n        Day06_sum day06_sum = new Day06_sum();\n        day06_sum.doAnything();\n        day06_sum.draw();\n    }\n}\n')])])]),a("h2",{attrs:{id:"内部类-需要好好看"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部类-需要好好看"}},[n._v("#")]),n._v(" 内部类(需要好好看)")])])}),[],!1,null,null,null);t.default=s.exports}}]);